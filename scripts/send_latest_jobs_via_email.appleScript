on run (argv)		set ret to sendMail("/Users/bryan/Dropbox/Job Search 2013/2014_04_05_newjobs_filtered.csv")		-- 	if (count of argv) = 0 then	-- 		log "Error: No file specified for sending."	-- 		return -1	-- 	else	-- 		set strFileToSend to first item of argv	-- 		if (characters 1 thru 1 of strFileToSend as string) = "\"" then	-- 			set strFileToSend to (characters 2 thru ((length of strFileToSend) - 1)) of strFileToSend as string	-- 		end if	-- 		log "Starting email send for CSV file = " & strFileToSend & "."	-- 	end if	-- 		-- 	set ret to sendMail(strFileToSend)	if (ret < 0) then		log "An error occured sending the file."	end if		return retend runon sendMail(strFileToSend)		set recipName to "Bryan Selner"	set recipAddress to "selner@gmail.com"		set ret to -1		set theAttachmentFileFullPath to switchToPosixPathQuickHack(strFileToSend)	set theAttachmentFileName to getFileNameFromPath(theAttachmentFileFullPath)					set fileExists to "false"	try		tell application "Finder"			set myfile to (file theAttachmentFileFullPath) as alias			set fileExists to "true"		end tell	on error errM number errN			end try			if fileExists = "true" then		set theSubject to "New Job Postings Found:  " & theAttachmentFileName -- the subject		set theContent to "New job postings found and are attached.  File: " & theAttachmentFileName & return & return -- the content		log "Specified " & strFileToSend & " CSV file exists."			else		log "Could not find specified " & theAttachmentFileName & " CSV to send.  Sending failure alert."		set theSubject to "FAILED NEW POSTINGS" -- the subject		set theContent to "NEW JOB POSTINGS FAILED TO DOWNLOAD" --  " & strFileName & return & return -- the content		set theContent to theContent & "Could not find specified " & theAttachmentFileName & " CSV to send."		set ret to -1	end if		copy (current date) to aTimeDate	copy short date string of (aTimeDate) to aDate	set totalSeconds to (time of (aTimeDate))	set theHour to totalSeconds div 3600	set theMinutes to (totalSeconds mod 3600) div 60	set theSeconds to totalSeconds mod 60	copy (theHour as string) & ":" & theMinutes & ":" & theSeconds to aTime	copy aDate & " " & aTime to aTimeStamp		set theSubject to theSubject & " " & aTimeStamp	set theContent to theContent & return & return & "The job ran at " & aTimeStamp		--	set visible to false	set theSender to "bselner@icloud.com" -- the sender		tell application "Mail"		set curmsg to make new outgoing message with properties {subject:theSubject, content:theContent, visible:true}		--	set sender to theSender		tell curmsg			set sender to "bryan@bryanselner.com"			make new to recipient with properties {name:recipName, address:recipAddress}						if fileExists = "true" then								-- make new to recipient to recipients with properties {address:"selner@gmail.com"}				make new attachment with properties {file name:theAttachmentFileFullPath as alias}			end if		end tell				send curmsg		set ret to 1	end tell		return retend sendMailon getFileNameFromPath(strFilePath)	set strFileName to last item of my textToList(strFilePath, ":")	return strFileName	end getFileNameFromPathon switchToPosixPathQuickHack(strSlashPath)	# drop a leading / if there is one	set strMacPath to strSlashPath	if (characters 1 thru 1 of strSlashPath as string) = "/" then		set strMacPath to (characters 2 thru ((length of strSlashPath) - 1)) of strSlashPath as string	end if	# Now, just swap out all the / for :.   We'll mostly be in good shape then	set strMacPath to searchnreplace("/", ":", strSlashPath)	return strMacPathend switchToPosixPathQuickHack-- I am a very old search & replace function...on searchnreplace(searchstr, replacestr, txt)	considering case, diacriticals and punctuation		if txt contains searchstr then			set olddelims to AppleScript's text item delimiters			set AppleScript's text item delimiters to {searchstr}			set txtitems to text items of txt			set AppleScript's text item delimiters to {replacestr}			set txt to txtitems as Unicode text			set AppleScript's text item delimiters to olddelims		end if	end considering	return txtend searchnreplaceon textToList(theText, theDelimiter)	set saveDelim to AppleScript's text item delimiters	try		set AppleScript's text item delimiters to {theDelimiter}		set theList to every text item of theText	on error errStr number errNum		set AppleScript's text item delimiters to saveDelim		error errStr number errNum	end try	set AppleScript's text item delimiters to saveDelim	return (theList)end textToList